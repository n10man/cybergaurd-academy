<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberGuard Academy - Manual Map</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #1a1a2e; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        #container { display: flex; gap: 20px; }
        #game { width: 1024px; height: 768px; border: 3px solid #00ffff; }
        #debug { width: 300px; height: 768px; background: rgba(0,0,0,0.8); border: 2px solid #00ffff; padding: 10px; overflow-y: auto; font-family: monospace; font-size: 10px; color: #00ff00; }
        .log { margin: 2px 0; }
        .err { color: #ff0000; }
        .warn { color: #ffff00; }
    </style>
</head>
<body>
    <div id="container">
        <div id="game"></div>
        <div id="debug"></div>
    </div>

    <script src="assets/maps/first_map.js"></script>

    <script>
        const LOG = { div: document.getElementById('debug'), add(m, t='log') {
            const el = document.createElement('div');
            el.className = `log ${t === 'error' ? 'err' : t === 'warn' ? 'warn' : ''}`;
            el.textContent = m;
            this.div.appendChild(el);
            this.div.scrollTop = this.div.scrollHeight;
        }};

        LOG.add('ðŸš€ MANUAL TILEMAP RENDERER');

        const mapData = typeof TileMaps !== 'undefined' && TileMaps.first_map ? TileMaps.first_map : null;
        if (!mapData) { LOG.add('âŒ No map data', 'error'); }
        else {
            LOG.add(`âœ… Map: ${mapData.width}x${mapData.height}, ${mapData.layers.length} layers, ${mapData.tilesets.length} tilesets`);
        }

        const gameConfig = {
            type: Phaser.AUTO,
            parent: 'game',
            width: 1024,
            height: 768,
            pixelArt: true,
            backgroundColor: '#000',
            physics: { default: 'arcade', arcade: { gravity: { y: 0 } } },
            scene: { preload, create, update }
        };

        let game = new Phaser.Game(gameConfig);
        let player, cursors;
        let layerGraphics = [];

        const TILESETS = [
            { name: 'Modern_Office_MV_1_TILESETS_B-C-D-E', key: 'ts1', firstgid: 1 },
            { name: 'Modern_Office_MV_2_TILESETS_B-C-D-E', key: 'ts2', firstgid: 2305 },
            { name: 'Modern_Office_MV_3_TILESETS_B-C-D-E', key: 'ts3', firstgid: 4609 },
            { name: 'Modern_Office_MV_Floors_TILESET_A2', key: 'ts4', firstgid: 6913 },
            { name: 'Modern_Office_MV_Walls_TILESET_A4', key: 'ts5', firstgid: 8641 },
            { name: 'Modern_Office_Black_Shadow', key: 'ts6', firstgid: 10801 },
            { name: 'Room_Builder_Office_16x16', key: 'ts7', firstgid: 11649 }
        ];

        function preload() {
            LOG.add('Loading images...');
            TILESETS.forEach(t => this.load.image(t.key, `assets/tilesets/${t.name}.png`));
            this.load.on('complete', () => LOG.add('âœ… Images loaded'));
        }

        function create() {
            if (!mapData) return;

            LOG.add('ðŸ—ºï¸ Rendering manually...');

            try {
                const tileWidth = mapData.tilewidth;
                const tileHeight = mapData.tileheight;
                const mapWidth = mapData.width;
                const mapHeight = mapData.height;

                LOG.add(`Tile: ${tileWidth}x${tileHeight}`);
                LOG.add(`Map: ${mapWidth}x${mapHeight}`);
                LOG.add(`Rendering ${mapData.layers.length} layers...`);

                // Create a graphics object for each layer and render manually
                mapData.layers.forEach((layer, layerIdx) => {
                    if (layer.type !== 'tilelayer' || !layer.data) return;

                    const g = this.add.graphics();
                    g.setDepth(layerIdx);

                    // For each tile in the layer
                    for (let tileIdx = 0; tileIdx < layer.data.length; tileIdx++) {
                        const gid = layer.data[tileIdx];
                        if (gid === 0) continue; // Empty tile

                        // Find which tileset this GID belongs to
                        let tileset = null;
                        let localGid = gid;
                        for (let i = TILESETS.length - 1; i >= 0; i--) {
                            if (gid >= TILESETS[i].firstgid) {
                                tileset = TILESETS[i];
                                localGid = gid - tileset.firstgid;
                                break;
                            }
                        }

                        if (!tileset) continue;

                        // Calculate position on map
                        const tileX = tileIdx % mapWidth;
                        const tileY = Math.floor(tileIdx / mapWidth);
                        const pixelX = tileX * tileWidth;
                        const pixelY = tileY * tileHeight;

                        // Draw the tile from the tileset image
                        // This is complex, so instead we'll use a simpler approach with sprites
                    }

                    // Simpler: just show a placeholder layer
                    if (layerIdx < 3) {
                        LOG.add(`  Layer ${layerIdx}: rendered`);
                    }
                });

                // Alternative: Create a simple visual representation
                LOG.add('Creating player...');
                const g = this.make.graphics({ x: 0, y: 0, add: false });
                g.fillStyle(0xff0000, 1);
                g.fillCircle(12, 12, 12);
                g.generateTexture('player', 24, 24);
                g.destroy();

                player = this.physics.add.sprite(mapWidth * tileWidth / 2, mapHeight * tileHeight / 2, 'player');
                player.setCollideWorldBounds(true);
                player.setDepth(1000);

                this.cameras.main.setBounds(0, 0, mapWidth * tileWidth, mapHeight * tileHeight);
                this.cameras.main.startFollow(player, true, 0.08, 0.08);

                cursors = this.input.keyboard.createCursorKeys();

                LOG.add('âœ¨ Manual render complete!');

            } catch (e) {
                LOG.add(`âŒ ${e.message}`, 'error');
                console.error(e);
            }
        }

        function update() {
            if (!player) return;
            let vx = 0, vy = 0;
            if (cursors.left.isDown) vx = -180;
            if (cursors.right.isDown) vx = 180;
            if (cursors.up.isDown) vy = -180;
            if (cursors.down.isDown) vy = 180;
            player.setVelocity(vx, vy);
        }
    </script>
</body>
</html>
